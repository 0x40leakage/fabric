[ ] 多家背书：各背书节点对同一条 proposal 依次背书？顺序？
    - 否，发给各个 peer，app 汇总背书

From an application developer’s perspective, a smart contract, together with the ledger, form the heart of a Hyperledger Fabric blockchain system. Whereas a ledger holds facts about the current and historical state of a set of business objects, a smart contract defines the executable logic that generates new facts that are added to the ledger. 

A chaincode is typically used by administrators to group related smart contracts for deployment, but can also be used for low level system programming of Fabric.

Hyperledger Fabric users often use the terms smart contract and chaincode interchangeably. In general, a smart contract defines the transaction logic that controls the lifecycle of a business object contained in the world state. It is then packaged into a chaincode which is then deployed to a blockchain network. Think of smart contracts as governing transactions, whereas chaincode governs how smart contracts are packaged for deployment.  
A smart contract is a domain specific program which relates to specific business processes, whereas a chaincode is a technical container of a group of related smart contracts for installation and instantiation.

A smart contract programmatically accesses two distinct pieces of the ledger – **a blockchain**, which immutably records the history of all transactions, and a **world state** that holds a cache of the current value of these states, as it’s the current value of an object that is usually required.  
A delete typically represents the removal of a business object from the current state of the ledger, but not its history.

Deploying a chaincode to a network makes all its smart contracts available to the organizations in that network. It means that only administrators need to worry about chaincode; everyone else can think in terms of smart contracts.

Associated with every chaincode is an endorsement policy that applies to all of the smart contracts defined within it. An endorsement policy indicates which organizations in a blockchain network must sign a transaction generated by a given smart contract in order for that transaction to be declared valid.

The **input is signed** by the application’s organization ORG1, and the output is signed by both organizations identified by the endorsement policy, ORG1 and ORG2. These signatures were generated by using each actor’s private key, and mean that anyone in the network can verify that all actors in the network are in agreement about the transaction details.

A transaction that is distributed to all peer nodes in the network is validated in two phases. Firstly, the transaction is checked to ensure it has been signed by sufficient organizations according to the endorsement policy. Secondly, it is checked to ensure that the current value of the world state matches the read set of the transaction when it was signed by the endorsing peer nodes; that there has been no intermediate update.

An administrator defines an endorsement policy for a chaincode when it is instantiated on a channel, and can change it when the chaincode is upgraded. The endorsement policy applies equally to all smart contracts defined within the same chaincode deployed to a channel. It also means that a single smart contract can be deployed to different channels with different endorsement policies.

Smart Contracts are able to call to other smart contracts both **within the same channel and across different channels**. It this way, they can read and write world state data to which they would not otherwise have access due to smart contract namespaces.  
There are limitations to this inter-contract communication.

Lifecycle system chaincode (LSCC) runs in all peers to handle package signing, install, instantiate, and upgrade chaincode requests.  
Configuration system chaincode (CSCC) runs in all peers to handle changes to a channel configuration, such as a policy update.  
Query system chaincode (QSCC) runs in all peers to provide ledger APIs which include block query, transaction query etc.  
Endorsement system chaincode (ESCC) runs in endorsing peers to cryptographically sign a transaction response.  
Validation system chaincode (VSCC) validates a transaction, including checking endorsement policy and read-write set versioning. 