# cli
- `peer channel create -o orderer.example.com:7050 -c mychannel -f ./channel-artifacts/channel.tx --tls true --cafile $ORDERER_CA`

    ```go
    // package channel
    func init() {
        resetFlags()
    }
    // Explicitly define a method to facilitate tests
    func resetFlags() {
        // StringVar defines a string flag with specified name, default value, and usage string.
        // StringVarP is like StringVar, but accepts a shorthand letter that can be used after a single dash.
        flags.StringVarP(&chainID, "channelID", "c", common.UndefinedParamValue, "In case of a newChain command, the channel ID to create.")
        flags.StringVarP(&channelTxFile, "file", "f", "", "Configuration transaction file generated by a tool such as configtxgen for submitting to orderer")

        flags.IntVarP(&timeout, "timeout", "t", 5, "Channel creation timeout")

        flags.StringVarP(&genesisBlockPath, "blockpath", "b", common.UndefinedParamValue, "Path to file containing genesis block")
    }

    // package main
    mainCmd.AddCommand(channel.Cmd(nil))

    // package channel
    func Cmd(cf *ChannelCmdFactory) *cobra.Command {
        AddFlags(channelCmd)
        channelCmd.AddCommand(createCmd(cf))
        return channelCmd
    }
    // AddFlags adds flags for create and join
    func AddFlags(cmd *cobra.Command) {
        flags := cmd.PersistentFlags()
        flags.StringVarP(&orderingEndpoint, "orderer", "o", "", "Ordering service endpoint")
        flags.BoolVarP(&tls, "tls", "", false, "Use TLS when communicating with the orderer endpoint")
        flags.StringVarP(&caFile, "cafile", "", "", "Path to file containing PEM-encoded trusted certificate(s) for the ordering endpoint")
    }
    
    func createCmd(cf *ChannelCmdFactory) *cobra.Command {
        createCmd := &cobra.Command{
            Use:   "create",
            Short: createCmdDescription,
            Long:  createCmdDescription,
            RunE: func(cmd *cobra.Command, args []string) error {
                return create(cmd, args, cf)
            },
        }
        flagList := []string{
            "channelID",
            "file",
            "timeout",
        }
        attachFlags(createCmd, flagList)
        return createCmd
    }
    // 将已经定义好的 flag 加到 peer channel create 命令
    func attachFlags(cmd *cobra.Command, names []string) {
        cmdFlags := cmd.Flags()
        for _, name := range names {
            if flag := flags.Lookup(name); flag != nil {
                cmdFlags.AddFlag(flag)
            } else {
                logger.Fatalf("Could not find flag '%s' to attach to commond '%s'", name, cmd.Name())
            }
        }
    }

    func create(cmd *cobra.Command, args []string, cf *ChannelCmdFactory) error {
        if cf == nil {
            // InitCmdFactory init the ChannelCmdFactory with clients to endorser and orderer according to params
            cf, err = InitCmdFactory(EndorserNotRequired, PeerDeliverNotRequired, OrdererRequired)
            if err != nil {
                return err
            }
        }
        return executeCreate(cf)
    }
    // ChannelCmdFactory holds the clients used by ChannelCmdFactory
    type ChannelCmdFactory struct {
        EndorserClient   pb.EndorserClient
        Signer           msp.SigningIdentity
        BroadcastClient  common.BroadcastClient
        DeliverClient    deliverClientIntf
        BroadcastFactory BroadcastClientFactory
    }

    func executeCreate(cf *ChannelCmdFactory) error {
        if err = sendCreateChainTransaction(cf); err != nil {
            return err
        }
        var block *cb.Block
        if block, err = getGenesisBlock(cf); err != nil {
            return err
        }
        b, err := proto.Marshal(block)
        if err != nil {
            return err
        }
        file := chainID + ".block"
        if err = ioutil.WriteFile(file, b, 0644); err != nil {
            return err
        }
        return nil
    }
    func sendCreateChainTransaction(cf *ChannelCmdFactory) error {
        // Envelope wraps a Payload with a signature so that the message may be authenticated
        var chCrtEnv *cb.Envelope
        if channelTxFile != "" {
            if chCrtEnv, err = createChannelFromConfigTx(channelTxFile); err != nil {
                return err
            }
        } else {
            if chCrtEnv, err = createChannelFromDefaults(cf); err != nil {
                return err
            }
        }
        if chCrtEnv, err = sanityCheckAndSignConfigTx(chCrtEnv); err != nil {
            return err
        }
        var broadcastClient common.BroadcastClient
        broadcastClient, err = cf.BroadcastFactory()
        defer broadcastClient.Close()
        err = broadcastClient.Send(chCrtEnv)
    }
    func getGenesisBlock(cf *ChannelCmdFactory) (*common.Block, error) {
        timer := time.NewTimer(time.Second * time.Duration(timeout))
        defer timer.Stop()

        for {
            select {
            case <-timer.C:
                cf.DeliverClient.Close()
                return nil, fmt.Errorf("timeout waiting for channel creation")
            default:
                if block, err := cf.DeliverClient.getSpecifiedBlock(0); err != nil {
                    cf.DeliverClient.Close()
                    cf, err = InitCmdFactory(EndorserNotRequired, OrdererRequired)
                    if err != nil {
                        return nil, fmt.Errorf("failed connecting: %v", err)
                    }
                    time.Sleep(200 * time.Millisecond)
                } else {
                    cf.DeliverClient.Close()
                    return block, nil
                }
            }
        }
    }
    ```

- The `default` case in a `select` is run if no other case is ready. Use a `default` case to try and send or receive without blocking.